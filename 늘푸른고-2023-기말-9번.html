<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Math Video Player V27.3 (Hardcoded Layout – 4 Modes)</title>

<!-- MathJax 설정 -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [["$", "$"], ["\\(", "\\)"]],
    displayMath: [["$$", "$$"], ["\\[", "\\]"]],
    packages: {'[+]': ['ams', 'color', 'bbox']}
  },
  svg: { fontCache: 'global' },
  startup: { typeset: false }
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

<style>
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
:root {
  --solution-font-size: 28px;
  --dracula-bg: #282a36; --dracula-panel: #21222c;
  --dracula-selection: #44475a; --dracula-purple: #bd93f9; --chalk-white: #f8f8f2;
  --chalk-yellow: #F8E71C; --chalk-cyan: #8be9fd; --chalk-red: #FF5555; --chalk-grey: #6272a4;
}
html, body { width:100%; height:100%; margin:0; overflow:hidden; background:var(--dracula-bg); display:flex; justify-content:center; align-items:center; font-family:'Noto Sans KR',sans-serif; color:var(--chalk-white); }
#main-container { width:1920px; height:1080px; flex-shrink:0; display:flex; flex-direction:column; background:var(--dracula-panel); border-radius:15px; box-shadow:0 10px 30px rgba(0,0,0,0.5); position:relative; transform-origin:center center; }

/* 기본: 좌 4, 우 6 비율 */
#content-container { flex-grow:1; display:grid; grid-template-columns: 4fr 6fr; padding:24px 30px; gap:30px; min-height:0; }
.panel { background:var(--dracula-bg); border-radius:8px; box-shadow:inset 0 2px 4px rgba(0,0,0,0.3); padding:24px; display:flex; flex-direction:column; overflow:hidden; }
.panel-title { text-transform:uppercase; color:var(--dracula-purple); font-weight:700; font-size:calc(var(--solution-font-size)*1.1); margin:0 0 .8em; padding-bottom:.5em; border-bottom:1px solid var(--dracula-selection); flex-shrink:0; }

#visuals-wrapper { flex-grow:1; min-height:0; display:flex; flex-direction:column; gap:15px; }
#image-wrapper { flex:1; min-height:0; position:relative; border-radius:6px; overflow:hidden; background:#000; }
#graph-wrapper { flex:1; min-height:0; position:relative; border-radius:6px; overflow:hidden; }
#visuals-background-image { position:absolute; inset:0; width:100%; height:100%; object-fit:contain; }
#graph-canvas { display:block; width:100%; height:100%; }

#solution-wrapper { flex-grow:1; min-height:0; position:relative; overflow:hidden; }
.solution-page { display:none; width:100%; height:100%; overflow-y:auto; padding-right:15px; box-sizing:border-box; scrollbar-gutter:stable; }
.solution-page.is-active { display:block; }
.solution-page::-webkit-scrollbar { width:10px; }
.solution-page::-webkit-scrollbar-thumb { background:var(--dracula-selection); border-radius:5px; }
.solution-page::-webkit-scrollbar-thumb:hover { background:var(--chalk-grey); }
.solution-step { position:relative; padding-left:1.8em; margin:.5em 0; line-height:1.7; font-size:var(--solution-font-size); color:var(--chalk-white); }
.solution-step:not(.is-title)::before { content:'·'; position:absolute; left:0; line-height:inherit; color:inherit; }
.solution-step.is-title { padding-left:0; margin-top:1em; color:var(--chalk-cyan); font-weight:700; font-size:calc(var(--solution-font-size)*1.05); }

#controls-container { flex-shrink:0; height:90px; background:rgba(33,34,44,0.8); border-top:1px solid var(--dracula-selection); padding:0 30px; display:flex; justify-content:center; align-items:center; }
#player-controls { display:flex; align-items:center; width:100%; gap:20px; }
#play-pause-btn { background:transparent; border:none; color:white; font-size:38px; cursor:pointer; padding:0; width:50px; text-align:center; }
#timeline { flex-grow:1; height:10px; background:var(--dracula-selection); border-radius:5px; cursor:pointer; position:relative; }
#progress-bar { width:0%; height:100%; background:var(--dracula-purple); border-radius:5px; }
#time-display { font-size:22px; color:var(--chalk-grey); min-width:140px; text-align:center; }
#loading-overlay { position:absolute; inset:0; background:rgba(40,42,54,.95); z-index:100; display:flex; flex-direction:column; justify-content:center; align-items:center; color:white; font-size:36px; border-radius:15px; }
#loading-progress-text { font-size:.7em; margin-top:20px; color:var(--chalk-grey); }
#toast { position:absolute; bottom:110px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.75); color:#fff; padding:8px 12px; border-radius:6px; font-size:14px; display:none; }

/* 활성 스텝 하이라이트 */
.solution-step.is-active-step { background:rgba(189,147,249,.12); border-left:3px solid var(--dracula-purple); padding-left:1.3em; }

/* ========= 하드코딩 4 모드 =========
   CASE1: 원본X, 좌표계X  => Solution Full (좌측 패널 숨김, 우측이 전체 폭)
   CASE2: 원본O, 좌표계X  => Visual=이미지 Full (비주얼만 표시)
   CASE3: 원본X, 좌표계O  => Visual=그래프 Full (비주얼만 표시)
   CASE4: 원본O, 좌표계O  => Visual 상단 이미지, 하단 그래프 1:1
*/
/* 공통: Visuals 전용 레이아웃 */
.layout-case-2 #content-container,
.layout-case-3 #content-container,
.layout-case-4 #content-container { grid-template-columns: 4fr 6fr; }

/* CASE1: Solution Full */
.layout-case-1 #content-container { grid-template-columns: 1fr; }
.layout-case-1 #visuals-panel { display:none; }
.layout-case-1 #solution-panel { width:100%; }

/* CASE2: 이미지만 */
.layout-case-2 #visuals-panel { display:flex; }
.layout-case-2 #image-wrapper { display:block; flex:1 1 auto; }
.layout-case-2 #graph-wrapper { display:none; }
.layout-case-2 #visuals-background-image { object-fit:contain; }

/* CASE3: 그래프만 */
.layout-case-3 #visuals-panel { display:flex; }
.layout-case-3 #image-wrapper { display:none; }
.layout-case-3 #graph-wrapper { display:block; flex:1 1 auto; }

/* CASE4: 둘다(위/아래 반반) */
.layout-case-4 #visuals-panel { display:flex; }
.layout-case-4 #visuals-wrapper { display:flex; flex-direction:column; gap:15px; }
.layout-case-4 #image-wrapper { display:block; flex:1 1 50%; }
.layout-case-4 #graph-wrapper { display:block; flex:1 1 50%; }

/* 필요 시 이미지 확대 강도: cover 적용 옵션 */
.layout-image-zoom #visuals-background-image { object-fit:cover; }
</style>
</head>
<body>
<div id="main-container" class="layout-case-1">
  <div id="loading-overlay">
    <div>Loading V27.3 Player</div>
    <div id="loading-progress-text"></div>
  </div>
  <div id="content-container">
    <div id="visuals-panel" class="panel">
      <h2 class="panel-title">Visuals</h2>
      <div id="visuals-wrapper">
        <div id="image-wrapper"><img id="visuals-background-image" src="" alt="Problem Visual" /></div>
        <div id="graph-wrapper"><canvas id="graph-canvas"></canvas></div>
      </div>
    </div>
    <div id="solution-panel" class="panel">
      <h2 class="panel-title">Solution</h2>
      <div id="solution-wrapper"></div>
    </div>
  </div>
  <div id="controls-container">
    <div id="player-controls">
      <button id="play-pause-btn" aria-label="재생">▶</button>
      <div id="timeline"><div id="progress-bar"></div></div>
      <div id="time-display">0:00 / 0:00</div>
    </div>
  </div>
  <div id="toast"></div>
  <audio id="audio-player" preload="auto"></audio>
</div>

<script>
// V27.3 Data Injection (Improved Visuals with Labels)
var problemData = {
  "metadata": {
    "title": "늘푸른고 2023년 1학기 기말 12번",
    "problemId": "neulpureun-2023-1-final-12",
    "imageUrl": "",
    "invertImageForDarkBG": false,
    "imageZoomWhenSolo": false
  },
  "canvas_background_script": "const O={x:0,y:0},A={x:0,y:18},C={x:18,y:0},B={x:18,y:18},O_prime={x:6,y:18},M={x:3,y:9}; const faint='#6272a4'; drawGridAndAxes(); drawLine(O.x,O.y,A.x,A.y,faint,0.1); drawLine(A.x,A.y,B.x,B.y,faint,0.1); drawLine(B.x,B.y,C.x,C.y,faint,0.1); drawLine(C.x,C.y,O.x,O.y,faint,0.1); drawLine(O.x,O.y,O_prime.x,O_prime.y,faint,0.08,[0.3,0.3]); drawLine(-3,11,21,3,faint,0.1); drawPoint(O.x,O.y,faint); drawPoint(A.x,A.y,faint); drawPoint(C.x,C.y,faint); drawPoint(B.x,B.y,faint); drawPoint(O_prime.x,O_prime.y,faint); drawPoint(M.x,M.y,faint); drawMathText('O',-1.5,-1.5,faint); drawMathText('A',-1.5,18.5,faint); drawMathText('C',18.5,-1.5,faint); drawMathText('B',19.5,18.5,faint); drawMathText(\"O'\",6,19.5,faint); drawMathText('M',4,8.5,faint); drawMathText('P',-1,10.3,faint); drawMathText('Q',19.5,3.5,faint);",
  "audioUrls": [
    "https://raw.githubusercontent.com/sykaboom/triple-audio/main/audio/neulpureun-2023-1-final-12/neulpureun-2023-1-final-12_S001.mp3",
    "https://raw.githubusercontent.com/sykaboom/triple-audio/main/audio/neulpureun-2023-1-final-12/neulpureun-2023-1-final-12_S002.mp3",
    "https://raw.githubusercontent.com/sykaboom/triple-audio/main/audio/neulpureun-2023-1-final-12/neulpureun-2023-1-final-12_S003.mp3",
    "https://raw.githubusercontent.com/sykaboom/triple-audio/main/audio/neulpureun-2023-1-final-12/neulpureun-2023-1-final-12_S004.mp3",
    "https://raw.githubusercontent.com/sykaboom/triple-audio/main/audio/neulpureun-2023-1-final-12/neulpureun-2023-1-final-12_S005.mp3",
    "https://raw.githubusercontent.com/sykaboom/triple-audio/main/audio/neulpureun-2023-1-final-12/neulpureun-2023-1-final-12_S006.mp3",
    "https://raw.githubusercontent.com/sykaboom/triple-audio/main/audio/neulpureun-2023-1-final-12/neulpureun-2023-1-final-12_S007.mp3",
    "https://raw.githubusercontent.com/sykaboom/triple-audio/main/audio/neulpureun-2023-1-final-12/neulpureun-2023-1-final-12_S008.mp3",
    "https://raw.githubusercontent.com/sykaboom/triple-audio/main/audio/neulpureun-2023-1-final-12/neulpureun-2023-1-final-12_S009.mp3",
    "https://raw.githubusercontent.com/sykaboom/triple-audio/main/audio/neulpureun-2023-1-final-12/neulpureun-2023-1-final-12_S010.mp3",
    "https://raw.githubusercontent.com/sykaboom/triple-audio/main/audio/neulpureun-2023-1-final-12/neulpureun-2023-1-final-12_S011.mp3"
  ],
  "solutionSteps": [
    { "step_id": "s1", "latex": "\\(\\textbf{문제 풀이 시작}\\)", "is_title": true },
    { "step_id": "s2", "latex": "늘푸른고 2023년 1학기 기말 12번 문제 풀이를 시작하겠습니다." },
    { "step_id": "s3", "latex": "이 문제는 주어진 정사각형 종이접기 문제로, 평면좌표와 도형의 이동, 특히 대칭이동의 개념을 이용해서 해결할 수 있습니다." },
    { "step_id": "s4", "latex": "\\(\\textbf{문제 분석 및 조건 확인}\\)", "is_title": true },
    { "step_id": "s5", "latex": "도형 정보: 한 변의 길이가 18인 정사각형 OABC가 좌표평면에 놓여 있습니다." },
    { "step_id": "s6", "latex": "점 O (원점): \\((0,0)\\)" },
    { "step_id": "s7", "latex": "점 A (y축 위): \\((0,18)\\)" },
    { "step_id": "s8", "latex": "점 C (x축 위): \\((18,0)\\)" },
    { "step_id": "s9", "latex": "점 B: \\((18,18)\\)" },
    { "step_id": "s10", "latex": "종이접기 (대칭이동): 선분 PQ를 접는 선으로 하여 종이를 접습니다." },
    { "step_id": "s11", "latex": "점 \\(O(0, 0)\\)는 선분 AB 위의 점 \\(O'\\)으로 이동합니다." },
    { "step_id": "s12", "latex": "선분 AB는 직선 \\(y=18\\) 위에 있으므로, \\(O'\\)의 좌표를 \\((a, 18)\\)로 둘 수 있습니다." },
    { "step_id": "s13", "latex": "풀이 과정에 따라 \\(a=6\\)으로 계산되었으므로, \\(O'\\)의 좌표는 \\((6,18)\\)입니다." },
    { "step_id": "s14", "latex": "목표: 접는 선인 직선 PQ의 방정식을 \\(y=mx+n\\) 형태로 구한 뒤, \\(6mn\\)의 값을 계산하는 것입니다." },
    { "step_id": "s15", "latex": "\\(\\textbf{접근 전략 수립}\\)", "is_title": true },
    { "step_id": "s16", "latex": "종이를 접는다는 것은 선대칭 이동을 의미합니다." },
    { "step_id": "s17", "latex": "접는 선(직선 PQ)은 다음의 두 가지 중요한 성질을 가집니다." },
    { "step_id": "s18", "latex": "1. 수직 조건: 선분 OO'은 접는 선 PQ와 수직입니다." },
    { "step_id": "s19", "latex": "두 직선의 수직 조건 \\((m_{PQ} \\times m_{OO'} = -1)\\)을 이용하여 직선 PQ의 기울기 \\(m\\)을 찾을 수 있습니다." },
    { "step_id": "s20", "latex": "2. 이등분 조건: 선분 OO'의 중점은 반드시 접는 선 PQ 위에 존재합니다." },
    { "step_id": "s21", "latex": "선분의 중점 공식을 사용하여 선분 OO'의 중점 좌표를 구합니다." },
    { "step_id": "s22", "latex": "이 점은 직선 PQ가 지나는 한 점이 됩니다." },
    { "step_id": "s23", "latex": "위 두 조건을 이용해 직선 PQ의 기울기와 지나는 한 점을 알아냅니다." },
    { "step_id": "s24", "latex": "점과 기울기가 주어진 직선의 방정식 \\(y - y_1 = m(x - x_1)\\)을 사용하여 방정식을 완성합니다." },
    { "step_id": "s25", "latex": "\\(\\textbf{단계별 풀이 과정}\\)", "is_title": true },
    { "step_id": "s26", "latex": "\\(\\textbf{1. 직선 PQ의 기울기 m 구하기}\\)" },
    { "step_id": "s27", "latex": "점 \\(O(0, 0)\\)과 점 \\(O'(6, 18)\\)을 잇는 선분 OO'의 기울기를 계산합니다." },
    { "step_id": "s28", "latex": "선분 OO'의 기울기 \\( = \\frac{18-0}{6-0} = 3 \\)" },
    { "step_id": "s29", "latex": "직선 PQ는 선분 OO'과 수직이므로, 두 기울기의 곱은 -1이 되어야 합니다." },
    { "step_id": "s30", "latex": "\\( m \\times 3 = -1 \\)" },
    { "step_id": "s31", "latex": "\\( \\therefore m = -\\frac{1}{3} \\)" },
    { "step_id": "s32", "latex": "\\(\\textbf{2. 직선 PQ가 지나는 점 구하기}\\)" },
    { "step_id": "s33", "latex": "직선 PQ는 선분 OO'의 중점을 지납니다. 중점의 좌표를 \\((x_1, y_1)\\)이라고 하겠습니다." },
    { "step_id": "s34", "latex": "\\( x_1 = \\frac{0+6}{2} = 3 \\)" },
    { "step_id": "s35", "latex": "\\( y_1 = \\frac{0+18}{2} = 9 \\)" },
    { "step_id": "s36", "latex": "따라서 직선 PQ는 점 \\((3, 9)\\)를 지납니다." },
    { "step_id": "s37", "latex": "\\(\\textbf{3. 직선 PQ의 방정식 구하기}\\)" },
    { "step_id": "s38", "latex": "기울기가 \\(m=-\\frac{1}{3}\\)이고 점 \\((3, 9)\\)를 지나는 직선의 방정식을 구합니다." },
    { "step_id": "s39", "latex": "\\( y - y_1 = m(x - x_1) \\)" },
    { "step_id": "s40", "latex": "\\( y - 9 = -\\frac{1}{3}(x - 3) \\)" },
    { "step_id": "s41", "latex": "식을 \\(y=mx+n\\) 꼴로 정리합니다." },
    { "step_id": "s42", "latex": "\\( y - 9 = -\\frac{1}{3}x + 1 \\)" },
    { "step_id": "s43", "latex": "\\( y = -\\frac{1}{3}x + 10 \\)" },
    { "step_id": "s44", "latex": "\\(\\textbf{4. 6mn의 값 계산하기}\\)" },
    { "step_id": "s45", "latex": "위에서 구한 직선의 방정식에서 \\(m=-\\frac{1}{3}\\)이고 \\(n=10\\)임을 알 수 있습니다." },
    { "step_id": "s46", "latex": "이 값들을 \\(6mn\\)에 대입하여 최종 값을 계산합니다." },
    { "step_id": "s47", "latex": "\\( 6mn = 6 \\times (-\\frac{1}{3}) \\times 10 \\)" },
    { "step_id": "s48", "latex": "\\( = -2 \\times 10 = -20 \\)" },
    { "step_id": "s49", "latex": "\\(\\textbf{결론 도출}\\)", "is_title": true },
    { "step_id": "s50", "latex": "접는 선인 직선 PQ의 방정식은 \\(y=-\\frac{1}{3}x+10\\) 이며, 문제에서 요구하는 \\(6mn\\)의 값은 -20 입니다." }
  ],
  "scenes": [
    { "scene_id": 1, "solutionHighlightIds": ["s1", "s2", "s3"], "canvas_script": "", "useImage": false, "layoutOverride": "CASE1" },
    { "scene_id": 2, "solutionHighlightIds": ["s5", "s6", "s7", "s8", "s9"], "canvas_script": "const O={x:0,y:0},A={x:0,y:18},C={x:18,y:0},B={x:18,y:18}; const bright='#f8f8f2'; drawLine(O.x,O.y,A.x,A.y,bright,0.1); drawLine(A.x,A.y,B.x,B.y,bright,0.1); drawLine(B.x,B.y,C.x,C.y,bright,0.1); drawLine(C.x,C.y,O.x,O.y,bright,0.1); drawPoint(O.x,O.y,bright); drawMathText('O(0,0)',-2,-2,bright); drawPoint(A.x,A.y,bright); drawMathText('A(0,18)',-2,19,bright); drawPoint(C.x,C.y,bright); drawMathText('C(18,0)',20,-2,bright); drawPoint(B.x,B.y,bright); drawMathText('B(18,18)',20,19,bright);", "useImage": false },
    { "scene_id": 3, "solutionHighlightIds": ["s10", "s11", "s12", "s13", "s14"], "canvas_script": "const O_prime={x:6,y:18}; drawPoint(O_prime.x,O_prime.y,'#f1fa8c'); drawMathText(\"O'(6,18)\",6,19.5,'#f1fa8c'); drawLine(0,0,6,18,'#ff79c6',0.08,[0.3,0.3]);", "useImage": false },
    { "scene_id": 4, "solutionHighlightIds": ["s16", "s17", "s18", "s19"], "canvas_script": "drawLine(-3,11,21,3,'#8be9fd',0.15); drawMathText('P',-1,10.3,'#8be9fd'); drawMathText('Q',19.5,3.5,'#8be9fd'); drawLine(0,0,6,18,'#ff79c6',0.1); drawMathText('⊥',3.5,8.5,'#ff5555',1.5);", "useImage": false },
    { "scene_id": 5, "solutionHighlightIds": ["s20", "s21", "s22", "s23", "s24"], "canvas_script": "const M={x:3,y:9}; drawPoint(M.x,M.y,'#f1fa8c',0.35); drawMathText('M(3,9)',M.x+2.5,M.y,'#f1fa8c');", "useImage": false },
    { "scene_id": 6, "solutionHighlightIds": ["s26", "s27", "s28"], "canvas_script": "drawLine(0,0,6,18,'#F8E71C',0.2); drawMathText('기울기=3', 4, 3, '#F8E71C', 1.2);", "useImage": false },
    { "scene_id": 7, "solutionHighlightIds": ["s29", "s30", "s31"], "canvas_script": "drawLine(-3,11,21,3,'#F8E71C',0.25); drawMathText('기울기=-1/3', 12, 12, '#F8E71C', 1.2);", "useImage": false },
    { "scene_id": 8, "solutionHighlightIds": ["s32", "s33", "s34", "s35", "s36"], "canvas_script": "const M={x:3,y:9}; drawPoint(M.x,M.y,'#F8E71C',0.5); drawMathText('M(3,9)',M.x+2.5,M.y,'#F8E71C');", "useImage": false },
    { "scene_id": 9, "solutionHighlightIds": ["s37", "s38", "s39", "s40", "s41", "s42", "s43"], "canvas_script": "drawLine(-3,11,21,3,'#8be9fd',0.2); drawMathText('y = -1/3 x + 10', 9, 14, '#8be9fd', 1.5);", "useImage": false },
    { "scene_id": 10, "solutionHighlightIds": ["s44", "s45", "s46", "s47", "s48"], "canvas_script": "drawMathText('m=-1/3, n=10', 10, 5, '#f8f8f2', 1.2); drawMathText('6mn = -20', 10, 2, '#ff5555', 1.8);", "useImage": false },
    { "scene_id": 11, "solutionHighlightIds": ["s49", "s50"], "canvas_script": "drawLine(-3,11,21,3,'#8be9fd',0.15); drawMathText('y = -1/3 x + 10', 9, 14, '#8be9fd', 1.5); drawMathText('Final Answer: -20', 9, 10, '#ff5555', 2.5);", "useImage": false }
  ]
};

(function() {
  'use strict';

  const CONFIG = { WIDTH: 1920, HEIGHT: 1080, MARGIN_FACTOR: 0.95 };

  const ui = {
    solutionWrapper: document.getElementById('solution-wrapper'),
    visualsWrapper: document.getElementById('visuals-wrapper'),
    visualsBG: document.getElementById('visuals-background-image'),
    canvas: document.getElementById('graph-canvas'),
    ctx: null,
    audio: document.getElementById('audio-player'),
    playPauseBtn: document.getElementById('play-pause-btn'),
    progressBar: document.getElementById('progress-bar'),
    timeDisplay: document.getElementById('time-display'),
    timeline: document.getElementById('timeline'),
    loading: document.getElementById('loading-overlay'),
    loadingProgress: document.getElementById('loading-progress-text'),
    mainContainer: document.getElementById('main-container'),
    graphWrapper: document.getElementById('graph-wrapper'),
    imageWrapper: document.getElementById('image-wrapper'),
    visualsPanel: document.getElementById('visuals-panel'),
    toast: document.getElementById('toast')
  };

  const state = {
    currentSceneIndex: -1,
    totalDuration: 0,
    sceneStartTimes: [],
    sceneDurations: [],
    isReady: false,
    isPlaying: false,
    isEnded: false,

    isSilentScene: false,
    currentTimeInScene: 0,
    scenePlaybackStartTime: 0
  };

  function showToast(msg, ms = 1600) { ui.toast.textContent = msg; ui.toast.style.display = 'block'; setTimeout(()=>{ ui.toast.style.display='none'; }, ms); }
  function handleResize(){ const vw=window.innerWidth, vh=window.innerHeight; const s=Math.min((vw/CONFIG.WIDTH)*CONFIG.MARGIN_FACTOR,(vh/CONFIG.HEIGHT)*CONFIG.MARGIN_FACTOR); ui.mainContainer.style.transform=`scale(${s})`; }
  const ctx = () => ui.ctx;

  function setupCanvas(retry=0){
    if(!ui.canvas||!ui.ctx) return;
    const dpr=window.devicePixelRatio||1; const lw=ui.canvas.clientWidth; const lh=ui.canvas.clientHeight;
    if(!lw||!lh){ if(retry<5) setTimeout(()=>setupCanvas(retry+1), 30*Math.pow(2,retry)); return; }
    ui.canvas.width=Math.max(1,Math.floor(lw*dpr)); ui.canvas.height=Math.max(1,Math.floor(lh*dpr));
    ui.ctx.setTransform(1,0,0,1,0,0); ui.ctx.clearRect(0,0,ui.canvas.width,ui.canvas.height); ui.ctx.scale(dpr,dpr);
    const vb={minX:-5,minY:-5,width:28,height:28}; const sc=Math.min(lw/vb.width, lh/vb.height); const ox=(lw-sc*vb.width)/2; const oy=(lh-sc*vb.height)/2;
    ui.ctx.translate(ox, oy+sc*vb.height); ui.ctx.scale(sc,-sc); ui.ctx.translate(-vb.minX, -vb.minY);
  }
  function drawGridAndAxes(color="#bd93f9"){ const b={minX:-2,minY:-2,maxX:22,maxY:22}; ctx().beginPath(); ctx().strokeStyle="#44475a"; ctx().lineWidth=0.05; for(let i=b.minX;i<=b.maxX;i+=2){ctx().moveTo(i,b.minY);ctx().lineTo(i,b.maxY);} for(let i=b.minY;i<=b.maxY;i+=2){ctx().moveTo(b.minX,i);ctx().lineTo(b.maxX,i);} ctx().stroke(); drawLine(b.minX,0,b.maxX,0,color,0.1); drawLine(0,b.minY,0,b.maxY,color,0.1); }
  function drawPoint(x,y,color="#f8f8f2",size=0.25){ ctx().beginPath(); ctx().fillStyle=color; ctx().arc(x,y,size,0,2*Math.PI); ctx().fill(); }
  function drawLine(x1,y1,x2,y2,color="#f8f8f2",lw=0.08,dash=[]){ ctx().beginPath(); ctx().strokeStyle=color; ctx().lineWidth=lw; ctx().setLineDash(dash); ctx().moveTo(x1,y1); ctx().lineTo(x2,y2); ctx().stroke(); ctx().setLineDash([]); }
  function drawMathText(text,x,y,color="#f8f8f2",size=1.2){ ctx().save(); ctx().fillStyle=color; ctx().scale(1,-1); ctx().textAlign="center"; ctx().font=`bold ${size}px 'Noto Sans KR', sans-serif`; ctx().fillText(text,x,-y); ctx().restore(); }

  function drawOnCanvas() {
    try {
      setupCanvas(); // 캔버스 초기화

      // 1. 모든 장면에 걸쳐 유지될 공통 배경을 먼저 그립니다.
      const bgScript = problemData.canvas_background_script;
      if (bgScript && bgScript.trim()) {
        try { eval(bgScript); } catch (e) { console.error('Canvas Background Script Error:', e); }
      }

      // 2. 현재 장면에만 해당하는 강조 효과를 덧그립니다.
      const sceneScript = problemData.scenes?.[state.currentSceneIndex]?.canvas_script;
      if (sceneScript && sceneScript.trim()) {
        try { eval(sceneScript); } catch (e) { console.error('Canvas Scene Script Error:', e); showToast('Canvas script error.'); }
      }
    } catch (err) {
      console.error('drawOnCanvas error', err);
    }
  }

  function initializeVisuals(){ ui.ctx = ui.canvas.getContext('2d',{alpha:false}); if(problemData?.metadata?.imageUrl){ ui.visualsBG.src = problemData.metadata.imageUrl; } ui.visualsBG.style.filter = problemData?.metadata?.invertImageForDarkBG?"invert(1) hue-rotate(180deg) brightness(1.1)":"none"; setupCanvas(); }

  function initializeSolution(){ const map=new Map(); (problemData.solutionSteps||[]).forEach(s=>map.set(s.step_id,s)); (problemData.scenes||[]).forEach((scene,idx)=>{ const page=document.createElement('div'); page.id=`page-${idx}`; page.className='solution-page'; (scene.solutionHighlightIds||[]).forEach(id=>{ const sd=map.get(id); if(sd){ const el=document.createElement('div'); el.id=`${id}-p${idx}`; el.className=`solution-step ${sd.is_title?'is-title':''}`; el.innerHTML=sd.latex; page.appendChild(el); } }); ui.solutionWrapper.appendChild(page); }); }

  async function measureAudioDurations(){ const n=(problemData.scenes||[]).length; const urls=problemData.audioUrls||[]; if(!n){ state.sceneDurations=[]; state.sceneStartTimes=[]; state.totalDuration=0; return; }
    const loadOne=(url)=>new Promise(res=>{ if(!url||typeof url!=="string"||!url.trim()) return res(5.0); const a=new Audio(); a.preload='metadata'; a.crossOrigin='anonymous'; const done=d=>res(Number.isFinite(d)&&d>0?d:5.0); a.onloadedmetadata=()=>done(a.duration); a.onerror=()=>done(5.0); a.src=url; try{a.load();}catch{done(5.0);} });
    const ps=Array.from({length:n},(_,i)=>{ if(i<urls.length) ui.loadingProgress.textContent=`Loading audio metadata: ${i+1} / ${urls.length}`; return loadOne(urls[i]); });
    const ds=await Promise.all(ps); state.sceneDurations=ds; state.totalDuration=ds.reduce((a,b)=>a+b,0); let cum=0; state.sceneStartTimes=ds.map(d=>{const s=cum; cum+=d; return s;}); }

  // 하드코딩 레이아웃 결정기: 4 모드 강제
  function applyLayoutForScene(scene){
    // layoutOverride가 있으면 최우선으로 적용
    if (scene.layoutOverride) {
        let cls = 'layout-case-1';
        switch (scene.layoutOverride.toUpperCase()) {
            case 'CASE1': cls = 'layout-case-1'; break;
            case 'CASE2': cls = 'layout-case-2'; break;
            case 'CASE3': cls = 'layout-case-3'; break;
            case 'CASE4': cls = 'layout-case-4'; break;
        }
        ui.mainContainer.className = 'layout-image-zoom ' + cls; // 기존 클래스 초기화 후 적용
        return;
    }

    const hasImage = !!(problemData?.metadata?.imageUrl && scene?.useImage !== false);
    const hasCanvas = !!((scene?.canvas_script && scene.canvas_script.trim()) || (problemData.canvas_background_script && problemData.canvas_background_script.trim()));

    let cls = 'layout-case-1';
    if (hasImage && !hasCanvas) cls = 'layout-case-2';
    else if (!hasImage && hasCanvas) cls = 'layout-case-3';
    else if (hasImage && hasCanvas) cls = 'layout-case-4';

    ui.mainContainer.classList.remove('layout-case-1','layout-case-2','layout-case-3','layout-case-4');
    ui.mainContainer.classList.add(cls);

    if (cls === 'layout-case-1') {
      ui.visualsPanel.style.display = 'none';
    } else {
      ui.visualsPanel.style.display = 'flex';
    }

    ui.imageWrapper.style.display = (hasImage && cls !== 'layout-case-3') ? 'block' : 'none';
    ui.graphWrapper.style.display = (hasCanvas && cls !== 'layout-case-2') ? 'block' : 'none';

    const zoomSolo = !!problemData?.metadata?.imageZoomWhenSolo;
    if (cls==='layout-case-2' && zoomSolo) ui.mainContainer.classList.add('layout-image-zoom'); else ui.mainContainer.classList.remove('layout-image-zoom');
  }

  function showScene(index, seekTime=0, forcePlay=null){
    if(!state.isReady || index<0 || index>=(problemData.scenes?.length||0)) return;
    const shouldResume = forcePlay!==null ? forcePlay : state.isPlaying;
    if(state.isPlaying) setPlayingState(false);

    state.currentSceneIndex = index;

    const active = document.querySelector('.solution-page.is-active');
    if(active){ active.classList.remove('is-active'); active.querySelectorAll('.is-active-step').forEach(el=>el.classList.remove('is-active-step')); }
    const page = document.getElementById(`page-${index}`); if(page){ page.classList.add('is-active'); page.scrollTop=0; }

    const scene = problemData.scenes?.[index] || {};
    (scene.solutionHighlightIds||[]).forEach(id=>{ const el=document.getElementById(`${id}-p${index}`); if(el) el.classList.add('is-active-step'); });

    applyLayoutForScene(scene);

    const url=(problemData.audioUrls&&problemData.audioUrls[index])||"";
    const t=Math.max(0,seekTime);
    state.isSilentScene = !(url && url.trim());
    state.currentTimeInScene = t;

    if(!state.isSilentScene){
      ui.audio.onloadeddata=null; ui.audio.oncanplay=null;
      const resume=()=>{ try{ ui.audio.currentTime=t; }catch(e){} if(shouldResume) setPlayingState(true); };
      ui.audio.addEventListener('loadeddata',resume,{once:true});
      ui.audio.addEventListener('canplay',resume,{once:true});
      ui.audio.src=url; try{ ui.audio.load(); }catch(e){}
      if(ui.audio.readyState>=HTMLMediaElement.HAVE_FUTURE_DATA) resume();
    } else { ui.audio.src=""; if(shouldResume) setPlayingState(true); }

    requestAnimationFrame(drawOnCanvas);
    updateUI();
  }

  let rafId=null; function animationLoop(){ if(state.isPlaying && state.isReady){ updateUI(); rafId=requestAnimationFrame(animationLoop);} else { rafId=null; } }
  function startLoop(){ if(!rafId) rafId=requestAnimationFrame(animationLoop); }

  function setPlayingState(play){ if(!state.isReady) return; if(play){ if(state.isEnded){ state.isEnded=false; showScene(0,0,true); return;} state.scenePlaybackStartTime=performance.now(); if(!state.isSilentScene){ const p=ui.audio.play(); if(p) p.catch(()=>showToast('Audio play failed')); } state.isPlaying=true; startLoop(); } else { if(state.isPlaying){ if(state.isSilentScene){ const e=(performance.now()-state.scenePlaybackStartTime)/1000; state.currentTimeInScene += e; } else { state.currentTimeInScene = ui.audio.currentTime||0; ui.audio.pause(); } } state.isPlaying=false; } updatePlayPauseButton(); }
  function handleSceneEnd(){ if(!state.isReady||state.isEnded) return; if(state.currentSceneIndex < problemData.scenes.length-1){ showScene(state.currentSceneIndex+1,0,true); } else { state.isEnded=true; setPlayingState(false); updateUI(true); } }
  function updateUI(force=false){ if(!state.isReady) return; if(force){ ui.progressBar.style.width='100%'; ui.timeDisplay.textContent=`${formatTime(state.totalDuration)} / ${formatTime(state.totalDuration)}`; updatePlayPauseButton(); return; }
    const dur=state.sceneDurations[state.currentSceneIndex]||0; let t=0; if(state.currentSceneIndex>=0){ if(!state.isSilentScene){ t=ui.audio.currentTime||0; } else { t=state.currentTimeInScene; if(state.isPlaying){ const e=(performance.now()-state.scenePlaybackStartTime)/1000; t+=e; } } }
    if(state.isPlaying && dur>0 && t>=dur-1e-3){ t=dur; handleSceneEnd(); return; }
    let abs=0; if(state.currentSceneIndex>=0 && state.sceneStartTimes.length>state.currentSceneIndex){ abs=state.sceneStartTimes[state.currentSceneIndex]+t; }
    const prog=state.totalDuration>0?Math.min(abs/state.totalDuration,1):0; ui.progressBar.style.width=`${prog*100}%`; ui.timeDisplay.textContent=`${formatTime(abs)} / ${formatTime(state.totalDuration)}`; updatePlayPauseButton(); }
  function updatePlayPauseButton(){ let label=""; if(state.isEnded){ ui.playPauseBtn.textContent='↻'; label='다시 재생'; } else if(state.isPlaying){ ui.playPauseBtn.textContent='❚❚'; label='일시 정지'; } else { ui.playPauseBtn.textContent='▶'; label='재생'; } ui.playPauseBtn.setAttribute('aria-label',label); }

  ui.playPauseBtn.addEventListener('click',()=>{ if(!state.isReady) return; setPlayingState(!state.isPlaying); });
  ui.timeline.addEventListener('click',(e)=>{ if(!state.isReady||state.totalDuration<=0) return; const was=state.isPlaying; const r=ui.timeline.getBoundingClientRect(); const target=(e.clientX-r.left)/r.width*state.totalDuration; let idx=state.sceneStartTimes.findIndex((st,i)=> tgt>=st && tgt<st+state.sceneDurations[i]); if(idx===-1) idx=state.sceneStartTimes.length-1; const seek=Math.max(0, target - state.sceneStartTimes[idx]); if(state.isEnded) state.isEnded=false; showScene(idx, seek, was); });
  ui.audio.addEventListener('ended',()=>{ if(!state.isSilentScene) handleSceneEnd(); });

  function formatTime(s){ if(!isFinite(s)||s<0) s=0; const m=Math.floor(s/60); const sec=Math.floor(s%60); return `${m}:${sec<10?'0':''}${sec}`; }
  async function waitForMathJax(){ const start=performance.now(); while(!window.MathJax || !MathJax.startup || !MathJax.typesetPromise){ await new Promise(r=>setTimeout(r,30)); if(performance.now()-start>10000) throw new Error('MathJax load timeout'); } }

  async function initializePlayer(){ if(!problemData||problemData.placeholder===true){ ui.loading.innerHTML='Error: Problem data invalid.'; return; }
    ui.audio.crossOrigin='anonymous'; window.addEventListener('resize',handleResize);
    initializeVisuals(); initializeSolution(); handleResize();
    try{ await waitForMathJax(); await MathJax.startup.promise; await MathJax.typesetPromise([ui.solutionWrapper]); await measureAudioDurations(); state.isReady=true; ui.loading.style.display='none'; showScene(0,0,false); updateUI(); }catch(err){ console.error('Init Error:',err); ui.loading.innerHTML='Error during initialization (MathJax/Audio).'; }
  }

  document.addEventListener('keydown',(e)=>{ if(!state.isReady) return; if(e.code==='Space'){ e.preventDefault(); setPlayingState(!state.isPlaying); } else if(e.key==='Home'){ e.preventDefault(); if(state.isEnded) state.isEnded=false; showScene(0,0,null); updateUI(); } else if(e.key==='End'){ e.preventDefault(); state.isEnded=true; setPlayingState(false); updateUI(); } else if(e.key==='ArrowRight'){ e.preventDefault(); seekRelative(5); } else if(e.key==='ArrowLeft'){ e.preventDefault(); seekRelative(-5); } });
  function seekRelative(d){ if(state.totalDuration<=0) return; const abs=(state.sceneStartTimes[state.currentSceneIndex]||0)+(!state.isSilentScene?(ui.audio.currentTime||0):(state.currentTimeInScene+(state.isPlaying?(performance.now()-state.scenePlaybackStartTime)/1000:0))); const tgt=Math.max(0, Math.min(state.totalDuration-0.001, abs+d)); let idx=state.sceneStartTimes.findIndex((st,i)=> tgt>=st && tgt<st+state.sceneDurations[i]); if(idx===-1) idx=state.sceneStartTimes.length-1; const seek=Math.max(0, tgt - state.sceneStartTimes[idx]); const was=state.isPlaying; showScene(idx, seek, was); }

  (function safeInit(){ const start=()=>initializePlayer(); if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded',start,{once:true}); } else { start(); } })();
})();
</script>
</body>
</html>

